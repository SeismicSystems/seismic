---
icon: sitemap
---

# Architecture

## Overview

Seismic is an EVM-compatible L1 blockchain with native on-chain privacy. The system is composed of three main components that work together to provide confidential smart contract execution:

| Component        | Role                                                               |
| ---------------- | ------------------------------------------------------------------ |
| **Seismic Node** | Transaction processing, state management, RPC -- runs inside a TEE |
| **Summit**       | Consensus and block production                                     |
| **Enclave**      | TEE operations: key management, encryption/decryption, attestation |

All three components are designed so that private data is only ever accessible inside the Trusted Execution Environment. No plaintext shielded data leaves the TEE boundary at any point in the pipeline.

***

## Seismic Node

The Seismic node is a fork of [reth](https://github.com/paradigmxyz/reth) (the Rust Ethereum execution client). It handles:

* **RPC**: Accepts incoming transactions and read requests. Serves responses to clients, redacting shielded data from public queries.
* **EVM execution**: Runs a modified EVM that supports `CLOAD`/`CSTORE` opcodes and the six Seismic [precompiles](../the-case-for-seismic/precompiles.md). This is built on a forked version of `revm`.
* **State management**: Maintains the world state using FlaggedStorage, where each storage slot is tagged as public or private.
* **Transaction pool**: Receives both standard Ethereum transactions and Seismic transactions (type `0x4A`). Encrypted calldata in Seismic transactions is decrypted inside the TEE before execution.

The entire node process runs inside an Intel TDX Trusted Execution Environment. This means the node operator cannot inspect memory, attach debuggers, or extract keys from the running process.

### Fork chain

The Seismic execution stack is built on a chain of forks from the Ethereum Rust ecosystem:

```
alloy-core  -->  revm  -->  reth
    |               |          |
seismic-alloy  seismic-revm  seismic-reth
```

* **seismic-alloy** (fork of alloy-core): Adds the Seismic transaction type (`0x4A`) and FlaggedStorage primitives to the core types.
* **seismic-revm** (fork of revm): Implements `CLOAD`/`CSTORE` opcodes and the Seismic precompiles in the EVM interpreter. Enforces the FlaggedStorage access rules at the opcode level.
* **seismic-reth** (fork of reth): Integrates the modified EVM into the full node, adding Enclave communication, modified RPC behavior (redacting private data), and TEE attestation.

FlaggedStorage flows through every layer of this stack. At the alloy level, it is a type definition. At the revm level, it governs opcode behavior. At the reth level, it determines what the RPC returns to callers.

***

## Summit (Consensus)

Summit is Seismic's consensus layer, built on [Commonware](https://github.com/commonwarexyz/monorepo) primitives. It handles:

* **Block production**: Ordering transactions into blocks with \~600ms block times.
* **Consensus**: Reaching agreement among validators on the canonical chain.
* **Finality**: Single-block finality -- once a block is produced and agreed upon, it is final.

Summit communicates with the Seismic node to receive transactions from the mempool and to deliver finalized blocks for execution.

***

## Enclave

The Enclave component manages all TEE-related operations. It is the trust anchor of the system.

### Key management

* **Genesis node**: When the network starts, the genesis node generates a root key inside the TEE. This key never leaves the enclave.
* **Peer nodes**: When a new node joins the network, it must pass remote attestation before receiving the root key. The existing nodes verify that the new node is running identical, approved code inside a genuine TEE.
* **Encryption secret key**: The root key is used to derive the network's encryption secret key. This key is used to decrypt the calldata of Seismic transactions (type `0x4A`).

### Attestation

Remote attestation is the process by which one TEE proves to another that it is running approved code on genuine hardware. In Seismic:

1. A new node generates an attestation report inside its TEE.
2. The report is sent to existing nodes for verification.
3. Existing nodes check that the report was generated by genuine Intel TDX hardware and that the code measurement matches the approved build.
4. Only after successful verification does the new node receive the root key.

This ensures that every node in the network is running the same software and that no node can be modified to leak private data.

***

## How the components interact

Here is the end-to-end flow when a user submits a Seismic transaction:

### 1. Client encrypts calldata

The user's client library (e.g., `seismic-viem`) fetches the TEE public key via `seismic_getTeePublicKey`. It performs ECDH key agreement between the user's private key and the TEE public key to derive a shared secret. The calldata is encrypted with AEAD and wrapped in a type `0x4A` transaction.

### 2. RPC receives the transaction

The Seismic node's RPC endpoint receives the encrypted transaction. At this point, the calldata is still encrypted -- the RPC layer does not decrypt it.

### 3. Enclave decrypts calldata

Inside the TEE, the Enclave component decrypts the calldata using the network's encryption secret key (derived from the root key). The plaintext calldata is now available only within the enclave's memory.

### 4. EVM executes the transaction

The modified EVM executes the transaction. When the contract reads shielded storage, it uses `CLOAD`. When it writes shielded storage, it uses `CSTORE`. The FlaggedStorage model ensures that:

* `CSTORE` sets `is_private = true` on the storage slot.
* `CLOAD` can read slots where `is_private = true`.
* `SLOAD` returns zero for slots where `is_private = true`.

### 5. State tree is updated

The world state trie is updated with the new FlaggedStorage values. Each slot stores `(value, is_private)`.

### 6. RPC serves responses

When external callers query the node:

* `eth_getStorageAt` fails for private slots.
* Transaction traces redact shielded values (replaced with `0x000`).
* Event logs contain only the data that was explicitly emitted (encrypted bytes if the developer used the AES precompiles, or public values if the event parameters are unshielded).

***

## TEE guarantees

The TEE (Trusted Execution Environment) is the foundation of Seismic's privacy model. Intel TDX provides the following guarantees:

### Code integrity

Remote attestation ensures that all nodes in the network are running identical, approved code. A node cannot be modified to log private data, skip encryption, or export keys.

### Memory isolation

The TEE creates a hardware-enforced boundary around the node's memory. The host operating system, hypervisor, and node operator cannot read or write to the enclave's memory space.

### Key protection

Cryptographic keys (the root key, encryption secret key, and any derived keys) are generated inside the TEE and never leave it. There is no API to export keys from the enclave. Even if the node operator has full root access to the host machine, they cannot extract the keys.

### What TEEs do not protect against

* **Side-channel attacks**: While Intel TDX mitigates many known side-channel attacks, this is an active area of research. Seismic's design minimizes the attack surface, but hardware-level side channels remain a theoretical concern.
* **Bugs in the node software**: If the approved node code has a bug that leaks private data through a public channel (e.g., writing shielded values to public storage), the TEE will faithfully execute that buggy code. This is why the code is open-source and subject to audit.
* **Transaction metadata**: The TEE protects calldata and storage values, but metadata such as sender address, gas usage, and the target contract address remain visible on-chain.
